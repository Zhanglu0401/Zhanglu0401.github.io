<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 茶九</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">茶九</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['人活在世，不如意的事常常发生！', '希望你不会难过太久，希望你能看到更美好的风景！', '因为：不保留的，才叫青春。不解释的，才叫从容。不放手的，才叫真爱。不完美的，才是人生！'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 150,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Vue/vue3优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/"
    >vue3优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2021-10-16T00:26:19.000Z" itemprop="datePublished">2021-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h2><p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p>
<p><img src="https://static.vue-js.com/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>试想一下，一个组件结构如下图</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p>
<p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
<h4 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p>
<p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p>
<p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p>
<p><img src="https://static.vue-js.com/c732e150-5c58-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>关于静态类型枚举如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p>
<p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;你好&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>没有做静态提升之前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做了静态提升之后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure>

<p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p>
<p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p>
<h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>没开启事件监听器缓存</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span><span class="title function_">_withId</span>(<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.<span class="property">onClick</span> &#125;, <span class="string">&quot;点我&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>开启事件侦听器缓存后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p>
<h4 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	...  <span class="comment">// 很多个静态属性</span></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>编译后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps <span class="keyword">as</span> _mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/server-renderer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _cssVars = &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: _ctx.<span class="property">color</span> &#125;&#125;</span><br><span class="line">  <span class="title function_">_push</span>(<span class="string">`&lt;div<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、源码体积"><a href="#二、源码体积" class="headerlink" title="二、源码体积"></a>二、源码体积</h2><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p>
<p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、响应式系统"><a href="#三、响应式系统" class="headerlink" title="三、响应式系统"></a>三、响应式系统</h2><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p>
<p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p>
<ul>
<li>可以监听动态属性的添加</li>
<li>可以监听到数组的索引和数组<code>length</code>属性</li>
<li>可以监听删除属性</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue/Vue3-设计目标、做了哪些优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"
    >Vue3-设计目标、做了哪些优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2021-10-11T13:19:27.000Z" itemprop="datePublished">2021-10-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h2><p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p>
<ul>
<li>随着功能的增长，复杂组件的代码变得越来越难以维护</li>
<li>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</li>
<li>类型推断不够友好</li>
<li><code>bundle</code>的时间太久了</li>
</ul>
<p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p>
<p>我们从结果反推</p>
<ul>
<li>更小</li>
<li>更快</li>
<li>TypeScript支持</li>
<li>API设计一致性</li>
<li>提高自身可维护性</li>
<li>开放更多底层功能</li>
</ul>
<p>一句话概述，就是更小更快更友好了</p>
<h3 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue3`移除一些不常用的 `API</span><br></pre></td></tr></table></figure>

<p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p>
<h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>主要体现在编译方面：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
<p>下篇文章我们会进一步介绍</p>
<h3 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h3><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p>
<p>这里代码简单演示下：</p>
<p>存在一个获取鼠标位置的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p>
<p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p>
<p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p>
<h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p>
<ul>
<li>源码</li>
<li>性能</li>
<li>语法 API</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以从两个层面展开：</p>
<ul>
<li>源码管理</li>
<li>TypeScript</li>
</ul>
<h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p>
<p><img src="https://static.vue-js.com/d7c32520-5c58-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p>
<p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3</code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p>
<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p>
<ul>
<li>体积优化</li>
<li>编译优化</li>
<li>数据劫持优化</li>
</ul>
<p>这里讲述数据劫持：</p>
<p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p>
<p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: &#123;</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p>
<p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p>
<h3 id="语法-API"><a href="#语法-API" class="headerlink" title="语法 API"></a>语法 API</h3><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p>
<ul>
<li>优化逻辑组织</li>
<li>优化逻辑复用</li>
</ul>
<h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><p>一张图，我们可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势</p>
<p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p>
<h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p>
<p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p>
<p>同样是上文的获取鼠标位置的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue/vue3-Treeshaking"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/29/Vue/vue3-Treeshaking/"
    >vue3-Treeshaking</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/29/Vue/vue3-Treeshaking/" class="article-date">
  <time datetime="2021-09-29T01:48:38.000Z" itemprop="datePublished">2021-09-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree shaking` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `Dead code elimination</span><br></pre></td></tr></table></figure>

<p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p>
<p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p>
<p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p>
<p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p>
<p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick, observable &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<p><code>Tree shaking</code>无非就是做了两件事：</p>
<ul>
<li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li>
<li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
<p>下面就来举个例子：</p>
<p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure>

<h3 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h3><p>组件中使用<code>data</code>属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: () =&gt; (&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>对项目进行打包，体积如下图</p>
<p><img src="https://static.vue-js.com/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">question</span>:<span class="string">&quot;&quot;</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再一次打包，发现打包出来的体积并没有变化</p>
<p><img src="https://static.vue-js.com/7c29e260-6097-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h3 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h3><p>组件中简单使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将项目进行打包</p>
<p><img src="https://static.vue-js.com/95df0000-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在组件中引入<code>computed</code>和<code>watch</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent, computed, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p>
<p><img src="https://static.vue-js.com/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h2 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h2><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p>
<ul>
<li>减少程序体积（更小）</li>
<li>减少程序执行时间（更快）</li>
<li>便于将来对程序架构进行优化（更友好）</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue/vue3-Proxy API 替代 defineProperty API "
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/26/Vue/vue3-Proxy%20API%20%E6%9B%BF%E4%BB%A3%20defineProperty%20API%20/"
    >vue3-Proxy API 替代 defineProperty API</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/26/Vue/vue3-Proxy%20API%20%E6%9B%BF%E4%BB%A3%20defineProperty%20API%20/" class="article-date">
  <time datetime="2021-09-26T04:54:42.000Z" itemprop="datePublished">2021-09-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h2><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p>
<h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="#为什么能实现响应式"></a><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F">#</a>为什么能实现响应式</h5><p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p>
<ul>
<li>get</li>
</ul>
<p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p>
<ul>
<li>set</li>
</ul>
<p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p>
<p>下面通过代码展示：</p>
<p>定义一个响应式函数<code>defineReactive</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>在对象存在多个<code>key</code>情况下，需要进行遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p>
<p>现在对一个对象进行删除与添加属性操作，无法劫持到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure>

<p>当我们对一个数组进行监听的时候，并不那么好使了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">&#125;)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p>
<p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p>
<p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>检测不到对象属性的添加和删除</li>
<li>数组<code>API</code>方法无法监听到</li>
<li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li>
</ul>
<h2 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h2><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p>
<p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p>
<p>下面通过代码进行展示：</p>
<p>定义一个响应式方法<code>reactive</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下简单数据的操作，发现都能劫持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure>

<p>如果要解决，需要在<code>get</code>之上再进行一层代理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p>
<p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;newbar&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue/vue3-Composition API详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/14/Vue/vue3-Composition%20API%E8%AF%A6%E8%A7%A3/"
    >vue3-Composition API详解
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/14/Vue/vue3-Composition%20API%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2021-09-14T03:26:49.000Z" itemprop="datePublished">2021-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>Composition API</code>也叫组合式API，是Vue3.x的新特性。</p>
<blockquote>
<p>通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。在处理如此大的应用程序时，共享和重用代码变得尤为重要</p>
</blockquote>
<p><strong>通俗的讲：</strong></p>
<p>没有<code>Composition API</code>之前vue相关业务的代码需要配置到option的特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的维护性比较复杂，同时代码可复用性不高。Vue3.x中的composition-api就是为了解决这个问题而生的</p>
<p><strong>compositon api提供了以下几个函数：</strong></p>
<ul>
<li><code>setup</code></li>
<li><code>ref</code></li>
<li><code>reactive</code></li>
<li><code>watchEffect</code></li>
<li><code>watch</code></li>
<li><code>computed</code></li>
<li><code>toRefs</code></li>
<li>生命周期的<code>hooks</code></li>
</ul>
<h2 id="一、setup组件选项"><a href="#一、setup组件选项" class="headerlink" title="一、setup组件选项"></a>一、setup组件选项</h2><blockquote>
<p>新的 <code>setup</code> 组件选项在<strong>创建组件之前</strong>执行，一旦 <code>props</code> 被解析，并充当合成 <code>API</code> 的入口点</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>由于在执行 <code>setup</code> 时尚未创建组件实例，因此在 <code>setup</code> 选项中没有 <code>this</code>。这意味着，除了<code>props</code>之外，你将无法访问组件中声明的任何属性——本地状态、计算属性或方法。</p>
</blockquote>
<p>使用 <code>setup</code> 函数时，它将接受两个参数：</p>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<p>让我们更深入地研究如何使用每个参数</p>
<h3 id="1-Props"><a href="#1-Props" class="headerlink" title="1. Props"></a>1. Props</h3><blockquote>
<p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 <code>prop</code> 时，它将被更新</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>但是，因为 <code>props</code> 是响应式的，你不能使用 <code>ES6</code> 解构，因为它会消除 <code>prop</code> 的响应性。</p>
</blockquote>
<p>如果需要解构 prop，可以通过使用 <code>setup</code> 函数中的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 来安全地完成此操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; toRefs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line">	const &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">	console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2. 上下文"></a>2. 上下文</h3><blockquote>
<p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露三个组件的 property</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // Attribute (非响应式对象)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    // 插槽 (非响应式对象)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    // 触发事件 (方法)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 更改应用副作用，那么应该在 <code>onUpdated</code>生命周期钩子中执行此操作。</p>
</blockquote>
<h3 id="3-setup组件的-property"><a href="#3-setup组件的-property" class="headerlink" title="3. setup组件的 property"></a>3. setup组件的 property</h3><blockquote>
<p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p>
</blockquote>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
</ul>
<h3 id="4-ref-reactive-以及setup结合模板使用"><a href="#4-ref-reactive-以及setup结合模板使用" class="headerlink" title="4. ref reactive 以及setup结合模板使用"></a>4. ref reactive 以及setup结合模板使用</h3><p>在看<code>setup</code>结合模板使用之前，我们首先得知道<code>ref</code> 和 <code>reactive</code> 方法。</p>
<p>如果 <code>setup</code> 返回一个对象则可以在模板中绑定对象中的属性和方法，但是要定义响应式数据的时候可以使用<code>ref</code>, <code>reactive</code>方法定义响应式的数据</p>
<h5 id="错误写法："><a href="#错误写法：" class="headerlink" title="错误写法："></a><strong>错误写法：</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = &quot;这是setup中的msg&quot;;</span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;)</span><br><span class="line">            msg = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="正确写法一："><a href="#正确写法一：" class="headerlink" title="正确写法一："></a><strong>正确写法一：</strong></h5><blockquote>
<p><strong>ref</strong>用来定义响应式的 字符串、 数值、 数组、<code>Bool</code>类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import &#123;  </span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line"></span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = ref(&quot;这是setup中的msg&quot;);</span><br><span class="line"></span><br><span class="line">        let list = ref([&quot;马总&quot;, &quot;李总&quot;, &quot;刘总&quot;])</span><br><span class="line"></span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            msg.value = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            list,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="正确写法二："><a href="#正确写法二：" class="headerlink" title="正确写法二："></a><strong>正确写法二：</strong></h5><p><strong>reactive</strong> 用来定义响应式的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    reactive   </span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变setup中的msg&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;setupData.title&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateTitle&quot;&gt;更新setup中的title&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = ref(&quot;这是setup中的msg&quot;);</span><br><span class="line"></span><br><span class="line">        let setupData = reactive(&#123;</span><br><span class="line">            title: &quot;reactive定义响应式数据的title&quot;,</span><br><span class="line">            userinfo: &#123;</span><br><span class="line">                username: &quot;张三&quot;,</span><br><span class="line">                age: 20</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            msg.value = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        let updateTitle = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            setupData.title = &quot;我是改变后的title&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            setupData,</span><br><span class="line">            updateMsg,</span><br><span class="line">            updateTitle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>**说明:**要改变ref定义的属性名称需要通过 <code>属性名称.value</code>来修改，要改变<code>reactive</code>中定义的对象名称可以直接</p>
<h3 id="5-使用-this"><a href="#5-使用-this" class="headerlink" title="5. 使用 this"></a>5. 使用 <code>this</code></h3><blockquote>
<p><strong>在 <code>setup()</code> 内部，<code>this</code> 不会是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这在和其它选项式 API 一起使用 <code>setup()</code> 时可能会导致混淆</p>
</blockquote>
<h2 id="二、toRefs-解构响应式对象数据"><a href="#二、toRefs-解构响应式对象数据" class="headerlink" title="二、toRefs - 解构响应式对象数据"></a>二、toRefs - 解构响应式对象数据</h2><blockquote>
<p>把一个响应式对象转换成普通对象，该普通对象的每个 <code>property</code> 都是一个 <code>ref</code> ，和响应式对象 <code>property</code> 一一对应</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user = reactive(&#123;</span><br><span class="line">            username: &quot;张三&quot;,</span><br><span class="line">            age: 10000,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 &#x2F; 扩展（使用 <code>…</code>操作符）返回的对象，并不会丢失响应性：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function useFeatureX() &#123;</span><br><span class="line">  const state = reactive(&#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 对 state 的逻辑操作</span><br><span class="line">  // ....</span><br><span class="line"></span><br><span class="line">  // 返回时将属性都转为 ref</span><br><span class="line">  return toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 可以解构，不会丢失响应性</span><br><span class="line">    const &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、computed-计算属性"><a href="#三、computed-计算属性" class="headerlink" title="三、computed - 计算属性"></a>三、computed - 计算属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据+computed&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; placeholder=&quot;firstName&quot; /&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; placeholder=&quot;lastName&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs,</span><br><span class="line">    computed</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user = reactive(&#123;</span><br><span class="line">            firstName: &quot;&quot;,</span><br><span class="line">            lastName: &quot;&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const fullName = computed(() =&gt; &#123;</span><br><span class="line">            return user.firstName + &quot; &quot; + user.lastName</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user),</span><br><span class="line">            fullName</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、readonly-“深层”的只读代理"><a href="#四、readonly-“深层”的只读代理" class="headerlink" title="四、readonly “深层”的只读代理"></a>四、readonly “深层”的只读代理</h2><blockquote>
<p>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;readonly - “深层”的只读代理&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive, readonly &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Readonly&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const original = reactive(&#123; count: 0 &#125;);</span><br><span class="line">    const copy = readonly(original);</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      original.count++;</span><br><span class="line">      copy.count++; // 报警告，Set operation on key &quot;count&quot; failed: target is readonly. Proxy &#123;count: 1&#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &#123; original, copy &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="五、watchEffect"><a href="#五、watchEffect" class="headerlink" title="五、watchEffect"></a>五、watchEffect</h2><blockquote>
<p>在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watchEffect - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;stop&quot;&gt;手动关闭侦听器&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watchEffect</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;WatchEffect&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const data = reactive(&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">            num: 1</span><br><span class="line">        &#125;);</span><br><span class="line">        const stop = watchEffect(() =&gt; console.log(`侦听器：$&#123;data.count&#125;`));</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            data.count++;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        return &#123;</span><br><span class="line">            data,</span><br><span class="line">            stop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、watch-、watch-与watchEffect区别"><a href="#六、watch-、watch-与watchEffect区别" class="headerlink" title="六、watch 、watch 与watchEffect区别"></a>六、watch 、watch 与watchEffect区别</h2><p>对比<code>watchEffect</code>，**<code>watch</code>允许我们**：</p>
<ul>
<li>懒执行，也就是说仅在侦听的源变更时才执行回调；</li>
<li>更明确哪些状态的改变会触发侦听器重新运行；</li>
<li>访问侦听状态变化前后的值</li>
</ul>
<p><strong>更明确哪些状态的改变会触发侦听器重新运行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;count1: &#123;&#123;data.count1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;count2: &#123;&#123;data.count2&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;stopAll&quot;&gt;Stop All&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watch</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const data = reactive(&#123;</span><br><span class="line">            count1: 0,</span><br><span class="line">            count2: 0</span><br><span class="line">        &#125;);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        const stop1 = watch(data, () =&gt;</span><br><span class="line">            console.log(&quot;watch1&quot;, data.count1, data.count2)</span><br><span class="line">        );</span><br><span class="line">        // 侦听多个数据源</span><br><span class="line">        const stop2 = watch([data], () =&gt; &#123;</span><br><span class="line">            console.log(&quot;watch2&quot;, data.count1, data.count2);</span><br><span class="line">        &#125;);</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            data.count1++;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        return &#123;</span><br><span class="line">            data,</span><br><span class="line">            stopAll: () =&gt; &#123;</span><br><span class="line">                stop1();</span><br><span class="line">                stop2();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>访问侦听状态变化前后的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    ref,</span><br><span class="line">    watch</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let keywords = ref(&quot;111&quot;);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        watch(keywords, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">            console.log(newValue, oldValue)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            keywords</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>懒执行，也就是说仅在侦听的源变更时才执行回调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;num1=&#123;&#123;num1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;num2=&#123;&#123;num2&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    ref,</span><br><span class="line">    watch,</span><br><span class="line">    watchEffect</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let num1 = ref(10);</span><br><span class="line">        let num2 = ref(10);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        watch(num1, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">            console.log(newValue, oldValue)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        watchEffect(() =&gt; console.log(`watchEffect侦听器：$&#123;num2.value&#125;`));</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            num1,</span><br><span class="line">            num2</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、组合式api生命周期钩子"><a href="#七、组合式api生命周期钩子" class="headerlink" title="七、组合式api生命周期钩子"></a>七、组合式api生命周期钩子</h2><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p>
<p>下表包含如何在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup ()</a> 内部调用生命周期钩子：</p>
<table>
<thead>
<tr>
<th align="left">选项式 API</th>
<th align="left">Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>beforeCreate</code></td>
<td align="left">不需要*</td>
</tr>
<tr>
<td align="left"><code>created</code></td>
<td align="left">不需要*</td>
</tr>
<tr>
<td align="left"><code>beforeMount</code></td>
<td align="left"><code>onBeforeMount</code></td>
</tr>
<tr>
<td align="left"><code>mounted</code></td>
<td align="left"><code>onMounted</code></td>
</tr>
<tr>
<td align="left"><code>beforeUpdate</code></td>
<td align="left"><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left"><code>onUpdated</code></td>
</tr>
<tr>
<td align="left"><code>beforeUnmount</code></td>
<td align="left"><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td align="left"><code>unmounted</code></td>
<td align="left"><code>onUnmounted</code></td>
</tr>
<tr>
<td align="left"><code>errorCaptured</code></td>
<td align="left"><code>onErrorCaptured</code></td>
</tr>
<tr>
<td align="left"><code>renderTracked</code></td>
<td align="left"><code>onRenderTracked</code></td>
</tr>
<tr>
<td align="left"><code>renderTriggered</code></td>
<td align="left"><code>onRenderTriggered</code></td>
</tr>
</tbody></table>
<blockquote>
<p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // mounted</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Component is mounted!&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Provider-Inject"><a href="#八、Provider-Inject" class="headerlink" title="八、Provider Inject"></a>八、Provider Inject</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-props.html">props</a>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人</p>
<blockquote>
<p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据</p>
</blockquote>
<h3 id="1-非组合式api中的写法"><a href="#1-非组合式api中的写法" class="headerlink" title="1. 非组合式api中的写法"></a>1. <strong>非组合式api中的写法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMap.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyMarker /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyMarker from &#x27;./MyMarker.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    location: &#x27;North Pole&#x27;,</span><br><span class="line">    geolocation: &#123;</span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- src/components/MyMarker.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#x27;location&#x27;, &#x27;geolocation&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-组合式api中的写法"><a href="#2-组合式api中的写法" class="headerlink" title="2. 组合式api中的写法"></a>2. <strong>组合式api中的写法</strong></h3><h5 id="Provider："><a href="#Provider：" class="headerlink" title="Provider："></a>Provider：</h5><blockquote>
<p>在 <code>setup()</code> 中使用 <code>provide</code> 时，我们首先从 <code>vue</code> 显式导入 <code>provide</code> 方法。这使我们能够调用 <code>provide</code> 时来定义每个 <code>property</code></p>
</blockquote>
<p><code>provide</code> 函数允许你通过两个参数定义 <code>property</code>：</p>
<ol>
<li><code>property</code> 的 <code>name</code> (&#96;&#96; 类型)</li>
<li><code>property</code> 的 <code>value</code></li>
</ol>
<p>使用 <code>MyMap</code> 组件，我们提供的值可以按如下方式重构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMap.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyMarker /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide &#125; from &#x27;vue&#x27;</span><br><span class="line">import MyMarker from &#x27;./MyMarker.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(&#x27;location&#x27;, &#x27;North Pole&#x27;)</span><br><span class="line">    provide(&#x27;geolocation&#x27;, &#123;</span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Inject"><a href="#Inject" class="headerlink" title="Inject:"></a>Inject:</h5><blockquote>
<p>在 <code>setup()</code> 中使用 <code>inject</code> 时，还需要从 <code>vue</code> 显式导入它。一旦我们这样做了，我们就可以调用它来定义如何将它暴露给我们的组件。</p>
</blockquote>
<p><code>inject</code> 函数有两个参数：</p>
<ol>
<li>要注入的 <code>property</code> 的名称</li>
<li>一个默认的值 (<strong>可选</strong>)</li>
</ol>
<p>使用 <code>MyMarker</code> 组件，可以使用以下代码对其进行重构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMarker.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)</span><br><span class="line">    const userGeolocation = inject(&#x27;geolocation&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Provider Inject 响应性</strong></p>
<p><strong>父组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    provide,</span><br><span class="line">    ref,</span><br><span class="line">    reactive</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">setup() &#123;</span><br><span class="line">        const location = ref(&#x27;北京&#x27;)</span><br><span class="line">        const geolocation = reactive(&#123;</span><br><span class="line">            longitude: 90,</span><br><span class="line">            latitude: 135</span><br><span class="line">        &#125;)</span><br><span class="line">        const updateLocation = () =&gt; &#123;</span><br><span class="line">            location.value = &#x27;上海&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        provide(&#x27;location&#x27;, location);</span><br><span class="line">        provide(&#x27;geolocation&#x27;, geolocation);</span><br><span class="line">        return &#123;</span><br><span class="line">            updateLocation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;button @click=&quot;updateLocation&quot;&gt;改变location&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)</span><br><span class="line">    const userGeolocation = inject(&#x27;geolocation&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue/vue3-Composition Api 与  Options Api 有什么不同"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/"
    >vue3-Composition Api 与  Options Api 有什么不同
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/" class="article-date">
  <time datetime="2021-09-02T09:23:09.000Z" itemprop="datePublished">2021-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p>
<p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p>
<ul>
<li>代码的可读性随着组件变大而变差</li>
<li>每一种代码复用的方式，都存在缺点</li>
<li>TypeScript支持有限</li>
</ul>
<p>以上通过使用<code>Composition Api</code>都能迎刃而解</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>
<p>如下图：</p>
<p><img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>
<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>
<h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<p><img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p>
<ul>
<li>逻辑组织</li>
<li>逻辑复用</li>
</ul>
<h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>
<p><img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>
<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>
<h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>
<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件上中使用<code>count</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>
<p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>
<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在组件中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure>

<p>会存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-React/Redux-action异步"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/23/React/Redux-action%E5%BC%82%E6%AD%A5/"
    >Redux action异步</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/04/23/React/Redux-action%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2020-04-23T12:07:48.000Z" itemprop="datePublished">2020-04-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、创建同步Action"><a href="#一、创建同步Action" class="headerlink" title="一、创建同步Action"></a>一、创建同步Action</h2><blockquote>
<p><code>Action</code>是数据从应用传递到 <code>store</code>&#x2F;<code>state</code> 的载体，也是开启一次完成数据流的开始</p>
</blockquote>
<p><strong>普通的action对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const action = &#123;</span><br><span class="line">	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">	name:&#x27;poetries&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(action)</span><br></pre></td></tr></table></figure>

<p><strong>封装action creator</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function actionCreator(data)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">    	data:data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(actionCreator(&#x27;poetries&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>bindActionCreators合并</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function a(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;a&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function b(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;b&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">actions.a(&#x27;poetries&#x27;,&#x27;id001&#x27;)</span><br><span class="line">actions.b(&#x27;jing&#x27;,&#x27;id002&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>action创建的标准</strong></p>
<blockquote>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p>
</blockquote>
<ul>
<li>是一个纯文本对象</li>
<li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li>
<li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li>
</ul>
<blockquote>
<p><code>payload</code> 是一个对象，用作Action携带数据的载体</p>
</blockquote>
<p><strong>标准action示例</strong></p>
<ul>
<li>A basic Flux Standard Action:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    text: &#x27;Do something.&#x27;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>An FSA that represents an error, analogous to a rejected Promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: new Error(),</span><br><span class="line">  error: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/acdlite/flux-standard-action">https://github.com/acdlite/flux-standard-action</a></p>
</blockquote>
<ul>
<li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// every有一个匹配不到返回false</span><br><span class="line">let isFSA = Object.keys(action).every((item)=&gt;&#123;</span><br><span class="line">   return  [&#x27;payload&#x27;,&#x27;type&#x27;,&#x27;error&#x27;,&#x27;meta&#x27;].indexOf(item) &gt;  -1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="二、创建异步action的多种方式"><a href="#二、创建异步action的多种方式" class="headerlink" title="二、创建异步action的多种方式"></a>二、创建异步action的多种方式</h2><blockquote>
<p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p>
</blockquote>
<p><strong>异步action的实现方式一：setTimeout</strong></p>
<blockquote>
<p><code>redux-thunk</code>中间处理解析</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function thunkAction(data) &#123;</span><br><span class="line">    reutrn (dispatch)=&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步action的实现方式二：promise实现异步action</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise`中间处理这种`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function promiseAction(name)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        setTimeout((param)=&gt;&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                name</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action2&quot;))</span><br><span class="line">        return;</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action3&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、redux异步流程"><a href="#三、redux异步流程" class="headerlink" title="三、redux异步流程"></a>三、redux异步流程</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/492.png" alt="img"></p>
<ul>
<li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li>
<li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li>
<li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li>
</ul>
<h2 id="四、Redux异步方案选型"><a href="#四、Redux异步方案选型" class="headerlink" title="四、Redux异步方案选型"></a>四、Redux异步方案选型</h2><p><strong>redux-thunk</strong></p>
<blockquote>
<p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p>
</blockquote>
<ul>
<li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li>
</ul>
<blockquote>
<p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p>
</blockquote>
<ul>
<li><code>redux-thunk</code></li>
<li><code>redux-promise</code></li>
</ul>
<blockquote>
<p><code>redux-thunk</code> 的源码如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123;</span><br><span class="line">    //请求之前的一些处理</span><br><span class="line"></span><br><span class="line">    let value = await Promise.resolve(val + &#x27; thunk&#x27;);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">        type:CONSTANT.ADD_TO_DO_THUNK,</span><br><span class="line">        payload:&#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>而它使用起来最大的问题，就是重复的模板代码太多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_SUCCESS = &#x27;GET_DATA_SUCCESS&#x27;,</span><br><span class="line">    GET_DATA_FAILED = &#x27;GET_DATA_FAILED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: GET_DATA, </span><br><span class="line">            payload: id</span><br><span class="line">        &#125;)</span><br><span class="line">        api.getData(id) //注：本文所有示例的api.getData都返回promise对象</span><br><span class="line">            .then(response =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_SUCCESS,</span><br><span class="line">                    payload: response</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(error =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_FAILED,</span><br><span class="line">                    payload: error</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = (oldState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA : </span><br><span class="line">        return oldState;</span><br><span class="line">    case GET_DATA_SUCCESS : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_FAILED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p>
</blockquote>
<ul>
<li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错<br>上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li>
</ul>
<p><strong>redux-promise</strong></p>
<blockquote>
<p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p>
</blockquote>
<ul>
<li><p>它自定义了一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>，当检测到有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br></pre></td></tr></table></figure>

<p>属性是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br></pre></td></tr></table></figure>

<p>对象时，就会</p>
<ul>
<li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>&quot;success&quot;</code></li>
<li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>&quot;error&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;;</span><br><span class="line"></span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: api.getData(id) //payload为promise对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">function reducer(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case GET_DATA: </span><br><span class="line">            if (action.status === &#x27;success&#x27;) &#123;</span><br><span class="line">                return successState</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                   return errorState</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p>
</blockquote>
<p><strong>场景解析之：乐观更新</strong></p>
<blockquote>
<p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p>
</blockquote>
<ul>
<li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li>
<li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li>
<li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li>
</ul>
<p><strong>redux-promise-middleware</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise-middleware`相比`redux-promise`，采取了更为温和和渐进式的思路，保留了和`redux-thunk`类似的三个`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_PENDING = &#x27;GET_DATA_PENDING&#x27;,</span><br><span class="line">    GET_DATA_FULFILLED = &#x27;GET_DATA_FULFILLED&#x27;,</span><br><span class="line">    GET_DATA_REJECTED = &#x27;GET_DATA_REJECTED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: &#123;</span><br><span class="line">            promise: api.getData(id),</span><br><span class="line">            data: id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = function(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA_PENDING :</span><br><span class="line">        return oldState; // 可通过action.payload.data获取id</span><br><span class="line">    case GET_DATA_FULFILLED : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_REJECTED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、redux异步操作代码演示"><a href="#五、redux异步操作代码演示" class="headerlink" title="五、redux异步操作代码演示"></a>五、redux异步操作代码演示</h2><ul>
<li>根据官网的async例子分析 <a target="_blank" rel="noopener" href="https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</a></li>
</ul>
<p><strong>action&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import fetch from &#x27;isomorphic-fetch&#x27;</span><br><span class="line">export const RECEIVE_POSTS = &#x27;RECEIVE_POSTS&#x27;</span><br><span class="line"></span><br><span class="line">//获取新闻成功的action</span><br><span class="line">function receivePosts(reddit, json) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    reddit: reddit,</span><br><span class="line">    posts: json.data.children.map(child =&gt;child.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetchPosts(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    </span><br><span class="line">    return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`)</span><br><span class="line">      .then(response =&gt; response.json())</span><br><span class="line">      .then(json =&gt;</span><br><span class="line">        dispatch(receivePosts(subreddit, json))</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要则开始获取文章</span><br><span class="line">export function fetchPostsIfNeeded(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return (dispatch, getState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      return dispatch(fetchPosts(subreddit))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p>
</blockquote>
<p><strong>reducers&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import &#123;</span><br><span class="line">  RECEIVE_POSTS</span><br><span class="line">&#125; from &#x27;../actions&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function posts(state = &#123;</span><br><span class="line">  items: []</span><br><span class="line">&#125;, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line"></span><br><span class="line">    case RECEIVE_POSTS:</span><br><span class="line">      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里</span><br><span class="line">      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span><br><span class="line">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        items: action.posts //数据都存在了这里</span><br><span class="line">      &#125;)</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将所有的reducer结合为一个,传给store</span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  postsByReddit</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default rootReducer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p>
</blockquote>
<p><strong>store&#x2F;configureStore.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;</span><br><span class="line">import thunkMiddleware from &#x27;redux-thunk&#x27;</span><br><span class="line">import createLogger from &#x27;redux-logger&#x27;</span><br><span class="line">import rootReducer from &#x27;../reducers&#x27;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">  thunkMiddleware,  </span><br><span class="line">  createLogger()  </span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line">export default function configureStore(initialState) &#123;</span><br><span class="line">  const store = createStoreWithMiddleware(rootReducer, initialState)</span><br><span class="line"></span><br><span class="line">  if (module.hot) &#123;</span><br><span class="line">    // Enable Webpack hot module replacement for reducers</span><br><span class="line">    module.hot.accept(&#x27;../reducers&#x27;, () =&gt; &#123;</span><br><span class="line">      const nextRootReducer = require(&#x27;../reducers&#x27;)</span><br><span class="line">      store.replaceReducer(nextRootReducer)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？<br>我们使用了<code>applyMiddleware()</code></li>
<li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li>
<li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li>
</ul>
<p><strong>界面上的调用：在containers&#x2F;App.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化渲染后触发</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch&#125; = this.props</span><br><span class="line">    // 这里可以传两个值，一个是 reactjs 一个是 frontend</span><br><span class="line">    dispatch(fetchPostsIfNeeded(&#x27;frontend&#x27;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p>
</blockquote>
<ul>
<li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;babel-core/polyfill&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; render &#125; from &#x27;react-dom&#x27;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;</span><br><span class="line">import App from &#x27;./containers/App&#x27;</span><br><span class="line">import configureStore from &#x27;./store/configureStore&#x27;</span><br><span class="line">const store = configureStore()</span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/493.png" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-React/React-性能优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/20/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
    >React性能优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/04/20/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2020-04-20T02:38:18.000Z" itemprop="datePublished">2020-04-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、重新认识render"><a href="#一、重新认识render" class="headerlink" title="一、重新认识render"></a>一、重新认识render</h2><blockquote>
<p><code>react</code>的组件渲染分为初始化渲染和更新渲染</p>
</blockquote>
<ul>
<li>在初始化渲染的时候会调用根组件下的所有组件的<code>render</code>方法进行渲染，如下图（绿色表示已渲染，这一层是没有问题的）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/420.png" alt="img"></p>
<p>但是当我们要更新某个子组件的时候，如下图的绿色组件（从根组件传递下来应用在绿色组件上的数据发生改变）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/421.png" alt="img"></p>
<p>我们的理想状态是只调用关键路径上组件的render</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/422.png" alt="img"></p>
<p>但是<code>react</code>的默认做法是调用所有组件的<code>render</code>，再对生成的虚拟<code>DOM</code>进行对比，如不变则不进行更新。这样的<code>render</code>和虚拟<code>DOM</code>的 对比 明显是在浪费，如下图（黄色表示浪费的<code>render</code>和虚拟<code>DOM</code>对比）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/423.png" alt="img"></p>
<p><strong>Tips</strong></p>
<ul>
<li>拆分组件是有利于复用和组件优化的</li>
<li>生成虚拟<code>DOM</code>并进行比对发生在<code>render()</code>后，而不是<code>render()</code>前</li>
</ul>
<h2 id="二、更新阶段的生命周期"><a href="#二、更新阶段的生命周期" class="headerlink" title="二、更新阶段的生命周期"></a>二、更新阶段的生命周期</h2><ul>
<li><code>componentWillReceiveProps(object nextProps)</code> ：当挂载的组件接收到新的<code>props</code>时被调用。此方法应该被用于比较<code>this.props</code> 和 <code>nextProps</code>以用于使用<code>this.setState()</code>执行状态转换。（组件内部数据有变化，使用<code>state</code>，但是在更新阶段又要在<code>props</code>改变的时候改变<code>state</code>，则在这个生命周期里面）</li>
<li><code>shouldComponentUpdate(object nextProps, object nextState)</code> ： -<code>boolean</code> 当组件决定任何改变是否要更新到<code>DOM</code>时被调用。作为一个 优化 实现比较<code>this.props</code> 和 <code>nextProps</code> 、<code>this.state</code> 和 <code>nextState</code> ，如果<code>React</code>应该跳过更新，返回<code>false</code></li>
<li><code>componentWillUpdate(object nextProps, object nextState</code>) ：在更新发生前被立即调用。你不能在此调用 <code>this.setState()</code></li>
<li><code>componentDidUpdate(object prevProps, object prevState</code>) ： 在更新发生后被立即调用。（可以在<code>DOM</code>更新完之后，做一些收尾的工作）</li>
</ul>
<p><strong>Tips</strong></p>
<ul>
<li><code>React</code>的优化是基于 <code>shouldComponentUpdate</code> 的，该生命周期默认返回<code>true</code>，所以一旦<code>prop</code>或<code>state</code>有任何变化，都会引起重新<code>render</code></li>
</ul>
<h2 id="三、shouldComponentUpdate"><a href="#三、shouldComponentUpdate" class="headerlink" title="三、shouldComponentUpdate"></a>三、shouldComponentUpdate</h2><blockquote>
<p><code>react</code>在每个组件生命周期更新的时候都会调用一个<code>shouldComponentUpdate(nextProps, nextState)</code>函数。它的职责就是返回<code>true</code>或<code>false</code>，true表示需要更新，<code>false</code>表示不需要，默认返回为<code>true</code>，即便你没有显示地定义 <code>shouldComponentUpdate</code> 函数。这就不难解释上面发生的资源浪费了</p>
</blockquote>
<p><strong>带坑的写法</strong></p>
<ul>
<li><code>&#123;...this.props&#125;</code> (不要滥用，请只传递<code>component</code>需要的<code>props</code>，传得太多，或者层次传得太深，都会加重<code>shouldComponentUpdate</code>里面的数据比较负担，因此，也请慎用<code>spread attributes（）)</code></li>
<li><code>::this.handleChange()。(请将方法的bind一律置于constructor)</code></li>
<li>复杂的页面不要在一个组件里面写完</li>
<li>请尽量使用<code>const element</code></li>
<li><code>map</code>里面添加<code>key</code>，并且<code>key</code>不要使用<code>index</code>（可变的)</li>
<li>尽量少用<code>setTimeOut</code>或不可控的<code>refs</code>、<code>DOM</code>操作</li>
<li>数据尽可能简单明了，扁平化</li>
</ul>
<h2 id="四、性能检测工具"><a href="#四、性能检测工具" class="headerlink" title="四、性能检测工具"></a>四、性能检测工具</h2><p><strong>React.addons.Perf</strong></p>
<blockquote>
<p><code>react</code>官方提供一个插件 <code>React.addons.Perf</code> 可以帮助我们分析组件的性能，以确定是否需要优化</p>
</blockquote>
<p><code>react16</code>以前需要在项目中配置，<code>react16</code>以后请看这篇文章，直接打开控制台的<code>perf</code>选项测试 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab">https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab</a></p>
<p><strong>react16之前配置</strong></p>
<ul>
<li>安装 <code>react</code> 性能检测工具 <code>npm i react-addons-perf --save</code>，然后在<code>./app/index.js</code>中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 性能测试</span><br><span class="line">import Perf from &#x27;react-addons-perf&#x27;</span><br><span class="line">if (__DEV__) &#123;</span><br><span class="line">    window.Perf = Perf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>console</code>面板，先输入 <code>Perf.start()</code> 执行一些组件操作，引起数据变动，组件更新，然后输入 <code>Perf.stop()</code> 。（建议一次只执行一个操作，好进行分析）</li>
<li>再输入 <code>Perf.printInclusive</code> 查看所有涉及到的组件<code>render</code>，如下图（官方图片）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/424.png" alt="img"></p>
<blockquote>
<p>或者输入<code>Perf.printWasted()</code>查看下不需要的的浪费组件<code>render</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/425.png" alt="img"></p>
<p>优化前</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/426.png" alt="img"></p>
<p>优化后</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/427.png" alt="img"></p>
<h2 id="五、其他优化"><a href="#五、其他优化" class="headerlink" title="五、其他优化"></a>五、其他优化</h2><p>1、<strong>前端通用优化。</strong>这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在 React 组件中。</p>
<p>2、<strong>减少不必要的组件更新。</strong>这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：<strong>减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染</strong>（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）</p>
<blockquote>
<p>PureComponent 是对<strong>类组件</strong>的 Props 和 State 进行浅比较；React.memo 是对<strong>函数组件</strong>的 Props 进行浅比较</p>
</blockquote>
<p>3、<strong>提交阶段优化。</strong>这类优化的目的是减少提交阶段耗时。</p>
<h3 id="1、组件按需加载"><a href="#1、组件按需加载" class="headerlink" title="1、组件按需加载"></a>1、组件按需加载</h3><p>组件按需加载优化又可以分为：<strong>懒加载、懒渲染、虚拟列表</strong> 三类。</p>
<p><strong>懒加载</strong></p>
<p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。在这些场景下，可以结合 Code Split 实现。</p>
<p>懒加载的实现主要是通过 Webpack 的动态导入和 <code>React.lazy</code> 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy, <span class="title class_">Suspense</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对加载失败进行容错处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里处理出错场景<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comp</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;模拟网络出错&quot;</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="title function_">import</span>(<span class="string">&quot;./Component&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginBottom:</span> <span class="attr">20</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&quot;Loading...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒渲染</strong></p>
<p>懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal&#x2F;Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。</p>
<p>懒渲染的使用场景有：</p>
<ol>
<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>
<li>需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。</li>
</ol>
<p>判断组件是否出现在可视区域内是通过 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/react-visibility-observer">react-visibility-observer</a> 进行监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VisibilityObserver</span>, &#123;</span><br><span class="line">  useVisibilityObserver,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-visibility-observer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">VisibilityObserverChildren</span> = (<span class="params">&#123; callback, children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isVisible &#125; = <span class="title function_">useVisibilityObserver</span>()</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(isVisible)</span><br><span class="line">  &#125;, [callback, isVisible])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;children&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">LazyRender</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isRendered, setIsRendered] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRendered) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">VisibilityObserver</span> <span class="attr">rootMargin</span>=<span class="string">&#123;</span>&quot;<span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">VisibilityObserverChildren</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">callback</span>=<span class="string">&#123;isVisible</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            if (isVisible) &#123;</span></span><br><span class="line"><span class="language-xml">              setIsRendered(true)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">VisibilityObserverChildren</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">VisibilityObserver</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;滚动到可视区域才渲染&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 LazyRender 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyRender</span></span><br></pre></td></tr></table></figure>

<p><strong>虚拟列表</strong></p>
<p>虚拟列表是懒渲染的一种特殊场景。实现虚拟列表的组件有 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://react-window.now.sh/%23/examples/list/fixed-size">react-window</a> 和 react-virtualized。react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好。新项目中推荐使用 react-window。</p>
<p>使用 react-window 很简单，只需要计算每项的高度即可。如果每项的高度是变化的，可给 itemSize 参数传一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FixedSizeList</span> <span class="keyword">as</span> <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-window&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; index, style &#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Row &#123;index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">height</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemCount</span>=<span class="string">&#123;1000&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemSize</span>=<span class="string">&#123;35&#125;</span> // <span class="attr">每项的高度为</span> <span class="attr">35</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">width</span>=<span class="string">&#123;300&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;Row&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2、批量更新"><a href="#2、批量更新" class="headerlink" title="2、批量更新"></a>2、批量更新</h3><h3 id="3、利用防抖、节流-避免重复回调"><a href="#3、利用防抖、节流-避免重复回调" class="headerlink" title="3、利用防抖、节流 避免重复回调"></a>3、利用防抖、节流 避免重复回调</h3><h3 id="4、缓存优化"><a href="#4、缓存优化" class="headerlink" title="4、缓存优化"></a>4、缓存优化</h3><p>缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。</p>
<ol>
<li>React 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://reactjs.org/docs/hooks-faq.html%23how-to-memoize-calculations">How to memoize calculations</a></li>
<li>useMemo 只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/memoizee">memoizee</a>。</li>
</ol>
<h3 id="5、列表项使用-key-属性"><a href="#5、列表项使用-key-属性" class="headerlink" title="5、列表项使用 key 属性"></a>5、列表项使用 key 属性</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-React/Redux-中间件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/17/React/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/"
    >Redux 中间件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/04/17/React/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time datetime="2020-04-17T09:32:28.000Z" itemprop="datePublished">2020-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li>在<code>redux</code>里，<code>middleware</code>是发送<code>action</code>和<code>action</code>到达<code>reducer</code>之间的第三方扩展，也就是中间层。也可以这样说，<code>middleware</code>是架在<code>action</code>和<code>store</code>之间的一座桥梁</li>
<li>在<code>redux</code>里，<code>action</code>仅仅是携带了数据的普通<code>js</code>对象</li>
</ul>
<blockquote>
<p><code>Reducer</code> 拆分可以使组件获取其最小属性(<code>state</code>)，而不需要整个<code>Store</code>。中间件则可以在<code>Action Creator</code> 返回最终可供 <code>dispatch</code> 调用的 <code>action</code> 之前处理各种事情，如异步<code>API</code>调用、日志记录等，是扩展 <code>Redux</code> 功能的一种推荐方式</p>
</blockquote>
<ul>
<li><code>Redux</code> 提供了 <code>applyMiddleware(...middlewares)</code> 来将中间件应用到 <code>createStore</code>。<code>applyMiddleware</code>会返回一个函数，该函数接收原来的 <code>creatStore</code> 作为参数，返回一个应用了 <code>middlewares</code> 的增强后的 <code>creatStore</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    //接收createStore参数</span><br><span class="line">    var store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    var dispatch = store.dispatch</span><br><span class="line">    var chain = []</span><br><span class="line"></span><br><span class="line">    //传递给中间件的参数</span><br><span class="line">    var middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //注册中间件调用链</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    //返回经middlewares增强后的createStore</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>未应用中间价之前，创建 <code>store</code> 的方式如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#x27;redux&#x27;;</span><br><span class="line">import reducers from &#x27;./reducers/index&#x27;;</span><br><span class="line"></span><br><span class="line">export let store = createStore(reducers);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用中间价之后，创建 <code>store</code>的方式如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore，applyMiddleware&#125; from &#x27;redux&#x27;;</span><br><span class="line">import reducers from &#x27;./reducers/index&#x27;;</span><br><span class="line"></span><br><span class="line">let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);</span><br><span class="line">export let store = createStoreWithMiddleware(reducers);</span><br></pre></td></tr></table></figure>

<h2 id="二、为什么要引入middleware"><a href="#二、为什么要引入middleware" class="headerlink" title="二、为什么要引入middleware"></a>二、为什么要引入middleware</h2><ul>
<li><code>action creator</code>返回的值是这个<code>action</code>类型的对象。然后通过<code>store.dispatch()</code>进行分发</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action ---&gt; dispatcher ---&gt; reducers</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写<code>ActionCreator</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var asyncSayActionCreator = function (message) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            type: &#x27;SAY&#x27;,</span><br><span class="line">            message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这会报错，因为这个<code>asyncSayActionCreator</code>返回的不是一个<code>action</code>，而是一个<code>function</code>。这个返回值无法被<code>reducer</code>识别</p>
</blockquote>
<ul>
<li>也就是说，正常来说，<code>action</code>返回的是一个对象，而不是一个函数。如果返回函数，会出现错误</li>
<li>　而异步操作呢，需要<code>action</code>的返回值是一个函数。那么咋办呢，所以需要引入中间件<code>middleware</code>,它在中间起到了桥梁的作用，让<code>action</code>的返回值可以是一个函数，从而传到<code>reducer</code>那里。也就是说，中间件是用在<code>action</code>发起之后，<code>reducer</code>接收到之前的这个时间段</li>
<li>也可以这么说，<code>Middleware</code> 主要是负责改变<code>Store</code>中的<code>dispatch</code>方法，从而能处理不同类型的 <code>action</code> 输入，得到最终的 <code>Javascript Plain Object</code> 形式的 <code>action</code> 对象</li>
</ul>
<blockquote>
<p>因此，上面那个<code>ActionCreator</code>就可以改写为这样：因为<code>action</code>的返回值是一个函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var asyncSayActionCreator = function (message) &#123;</span><br><span class="line">    return function (dispatch) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: &#x27;SAY&#x27;,</span><br><span class="line">                message</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/466.png" alt="img"></p>
<ul>
<li>上图表达的是 <code>redux</code> 中一个简单的同步数据流动的场景，点击<code>button</code> 后，在回调中 <code>dispatch</code> 一个 <code>action</code>，<code>reducer</code> 收到<code>action</code> 后，更新 <code>state</code> 并通知 <code>view</code> 重新渲染</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/467.png" alt="img"></p>
<ul>
<li><p>上面这张图展示了应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux</span><br></pre></td></tr></table></figure>

<p>处理事件的逻辑，每一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>处理一个相对独立的业务需求，通过串联不同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>，实现变化多样的的功能。那么问题来了：</p>
<ul>
<li><code>middleware</code> 怎么写？</li>
<li><code>redux</code>是如何让 <code>middlewares</code> 串联并跑起来的？</li>
</ul>
</li>
</ul>
<h2 id="三、中间件是如何工作的"><a href="#三、中间件是如何工作的" class="headerlink" title="三、中间件是如何工作的"></a>三、中间件是如何工作的</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Middleware`的中间件有很多，不过我的这个案例只引用了其中的一个，那就是`redux-thunk</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>redux-thunk</code>源码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">  return next =&gt; action =&gt;</span><br><span class="line">    typeof action === &#x27;function&#x27; ?</span><br><span class="line">      action(dispatch, getState) :</span><br><span class="line">      next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>意思是如果<code>action</code>是一个函数，执行这个<code>action</code>函数，如果不是函数，执行<code>next</code>函数</p>
</blockquote>
<h2 id="四、自定义中间件"><a href="#四、自定义中间件" class="headerlink" title="四、自定义中间件"></a>四、自定义中间件</h2><blockquote>
<p>中间件的签名如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; getState, dispatch &#125;) =&gt; next =&gt; action</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据<code>applyMiddleware</code> 源码，每个中间件接收 <code>getState &amp; dispatch</code>作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 <code>action</code> 的新函数</p>
</blockquote>
<ul>
<li>应用多个中间件时，中间件调用链中任何一个缺少 <code>next(action)</code> 的调用，都会导致<code>action</code> 执行失败</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123;</span><br><span class="line">    return next=&gt; action =&gt;&#123;</span><br><span class="line">        console.trace();</span><br><span class="line">        return next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在调用中间件部分添加中间件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">  thunkMiddleware,</span><br><span class="line">  loggerMiddleware,</span><br><span class="line">  callTraceMiddleware</span><br><span class="line">)(createStore);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux</code>的<code>middleware</code>是对<code>action</code>进行扩展处理，这样丰富了应用需求</p>
</blockquote>
<h2 id="五、常用的中间件"><a href="#五、常用的中间件" class="headerlink" title="五、常用的中间件"></a>五、常用的中间件</h2><p>有很多优秀的<code>redux</code>中间件，如：</p>
<ul>
<li>redux-thunk：用于异步操作</li>
<li>redux-logger：用于日志记录</li>
</ul>
<p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p>
<p>然后作为第二个参数传入到<code>createStore</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p><code>redux-thunk</code>是官网推荐的异步处理中间件</p>
<p>默认情况下的<code>dispatch(action)</code>，<code>action</code>需要是一个<code>JavaScript</code>的对象</p>
<p><code>redux-thunk</code>中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）</p>
<ul>
<li>dispatch函数用于我们之后再次派发action</li>
<li>getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态</li>
</ul>
<p>所以<code>dispatch</code>可以写成下述函数的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getHomeMultidataAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;http://xxx.xx.xx.xx/test&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeBannersAction</span>(data.<span class="property">banner</span>.<span class="property">list</span>));</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeRecommendsAction</span>(data.<span class="property">recommend</span>.<span class="property">list</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h3><p>如果想要实现一个日志功能，则可以使用现成的<code>redux-logger</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="title function_">createLogger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样我们就能简单通过中间件函数实现日志记录的信息</p>
<h2 id="六、实现原理"><a href="#六、实现原理" class="headerlink" title="六、实现原理"></a>六、实现原理</h2><p>首先看看<code>applyMiddlewares</code>的源码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">applyMiddleware</span>(<span class="params">...middlewares</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = <span class="title function_">createStore</span>(reducer, preloadedState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.<span class="property">dispatch</span>;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      <span class="attr">getState</span>: store.<span class="property">getState</span>,</span><br><span class="line">      <span class="attr">dispatch</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> <span class="title function_">dispatch</span>(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.<span class="title function_">map</span>(<span class="function"><span class="params">middleware</span> =&gt;</span> <span class="title function_">middleware</span>(middlewareAPI));</span><br><span class="line">    dispatch = <span class="title function_">compose</span>(...chain)(store.<span class="property">dispatch</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有中间件被放进了一个数组<code>chain</code>，然后嵌套执行，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法</p>
<p>在上面的学习中，我们了解到了<code>redux-thunk</code>的基本使用</p>
<p>内部会将<code>dispatch</code>进行一个判断，然后执行对应操作，原理如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchThunk</span>(<span class="params">store</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = store.<span class="property">dispatch</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatchAndThunk</span>(<span class="params">action</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store.<span class="property">dispatch</span> = dispatchAndThunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现一个日志输出的原理也非常简单，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.<span class="property">dispatch</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAndLog</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dispatching:&quot;</span>, <span class="title function_">addAction</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="title function_">next</span>(<span class="title function_">addAction</span>(<span class="number">5</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新的state:&quot;</span>, store.<span class="title function_">getState</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="property">dispatch</span> = dispatchAndLog;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-React/React-事件绑定方式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/13/React/React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/"
    >React-事件绑定方式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/04/13/React/React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2020-04-13T01:33:27.000Z" itemprop="datePublished">2020-04-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>react</code>应用中，事件名都是用小驼峰格式进行书写，例如<code>onclick</code>要改写成<code>onClick</code></p>
<p>最简单的事件绑定如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShowAlert</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">showAlert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showAlert&#125;</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，事件绑定的方法需要使用<code>&#123;&#125;</code>包住</p>
<p>上述的代码看似没有问题，但是当将处理函数输出代码换成<code>console.log(this)</code>的时候，点击按钮，则会发现控制台输出<code>undefined</code></p>
<h2 id="二、如何绑定"><a href="#二、如何绑定" class="headerlink" title="二、如何绑定"></a>二、如何绑定</h2><p>为了解决上面正确输出<code>this</code>的问题，常见的绑定方式有如下：</p>
<ul>
<li>render方法中使用bind</li>
<li>render方法中使用箭头函数</li>
<li>constructor中bind</li>
<li>定义阶段使用箭头函数绑定</li>
</ul>
<h3 id="render方法中使用bind"><a href="#render方法中使用bind" class="headerlink" title="render方法中使用bind"></a>render方法中使用bind</h3><p>如果使用一个类组件，在其中给某个组件&#x2F;元素一个<code>onClick</code>属性，它现在并会自定绑定其<code>this</code>到当前组件，解决这个问题的方法是在事件函数后使用<code>.bind(this)</code>将<code>this</code>绑定到当前组件中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在组件每次<code>render</code>渲染的时候，都会重新进行<code>bind</code>的操作，影响性能</p>
<h3 id="render方法中使用箭头函数"><a href="#render方法中使用箭头函数" class="headerlink" title="render方法中使用箭头函数"></a>render方法中使用箭头函数</h3><p>通过<code>ES6</code>的上下文来将<code>this</code>的指向绑定给当前组件，同样再每一次<code>render</code>的时候都会生成新的方法，影响性能</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constructor中bind"><a href="#constructor中bind" class="headerlink" title="constructor中bind"></a>constructor中bind</h2><p>在<code>constructor</code>中预先<code>bind</code>当前组件，可以避免在<code>render</code>操作中重复绑定</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义阶段使用箭头函数绑定"><a href="#定义阶段使用箭头函数绑定" class="headerlink" title="定义阶段使用箭头函数绑定"></a>定义阶段使用箭头函数绑定</h3><p>跟上述方式三一样，能够避免在<code>render</code>操作中重复绑定，实现也非常的简单，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>上述四种方法的方式，区别主要如下：</p>
<ul>
<li>编写方面：方式一、方式二写法简单，方式三的编写过于冗杂</li>
<li>性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例</li>
</ul>
<p>综合上述，方式四是最优的事件绑定方式</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/茶九.png" alt="茶九"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2126982915&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "123456";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "Please enter password",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "Ok",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "Incorrect password, please try again",
            confirmButtonText: "Ok",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>